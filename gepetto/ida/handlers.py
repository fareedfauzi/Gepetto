import functools
import json
import re
import time
import textwrap

import idaapi
import ida_hexrays
import idc

import gepetto.config
from gepetto.models.model_manager import instantiate_model

_ = gepetto.config._

def comment_callback(address, view, response, start_time):
    elapsed_time = time.time() - start_time
    response = "\n".join(textwrap.wrap(response, 80, replace_whitespace=False))
    comment = idc.get_func_cmt(address, 0)
    comment = re.sub(
        r'----- ' + _("Comment generated by Gepetto") + ' -----.*?----------------------------------------',
        r"",
        comment,
        flags=re.DOTALL)

    idc.set_func_cmt(address, '----- ' + _("Comment generated by Gepetto") +
                     f" -----\n\n"
                     f"{response.strip()}\n\n"
                     f"----------------------------------------\n\n"
                     f"{comment.strip()}", 0)
    if view:
        view.refresh_view(False)
    print(_("{model} query finished in {time:.2f} seconds!").format(model=str(gepetto.config.model), time=elapsed_time))

def conversation_callback(response, memory):
    memory.append({"role": "assistant", "content": response})
    print()
    for line in response.split("\n"):
        if not line.strip():
            continue
        print(f"{str(gepetto.config.model)}> {line}")
    print()

class ExplainHandler(idaapi.action_handler_t):
    def __init__(self):
        idaapi.action_handler_t.__init__(self)

    def activate(self, ctx):
        start_time = time.time()
        decompiler_output = ida_hexrays.decompile(idaapi.get_screen_ea())
        v = ida_hexrays.get_widget_vdui(ctx.widget)
        gepetto.config.model.query_model_async(
            _("Can you explain what the following C function does and suggest a better name for "
              "it?\n{decompiler_output}").format(decompiler_output=str(decompiler_output)),
            functools.partial(comment_callback, address=idaapi.get_screen_ea(), view=v, start_time=start_time))
        print(_("Request to {model} sent...").format(model=str(gepetto.config.model)))
        return 1

    def update(self, ctx):
        return idaapi.AST_ENABLE_ALWAYS

def rename_callback(address, view, response):
    names = json.loads(response)
    function_addr = idaapi.get_func(address).start_ea
    replaced = []
    for n in names:
        if idaapi.IDA_SDK_VERSION < 760:
            lvars = {lvar.name: lvar for lvar in view.cfunc.lvars}
            if n in lvars:
                if view.rename_lvar(lvars[n], names[n], True):
                    replaced.append(n)
        else:
            if ida_hexrays.rename_lvar(function_addr, n, names[n]):
                replaced.append(n)

    comment = idc.get_func_cmt(address, 0)
    if comment and len(replaced) > 0:
        for n in replaced:
            comment = re.sub(r'\b%s\b' % n, names[n], comment)
        idc.set_func_cmt(address, comment, 0)

    if view:
        view.refresh_view(True)
    print(_("{model} query finished! {replaced} variable(s) renamed.").format(model=str(gepetto.config.model),
                                                                              replaced=len(replaced)))

class RenameHandler(idaapi.action_handler_t):
    def __init__(self):
        idaapi.action_handler_t.__init__(self)

    def activate(self, ctx):
        decompiler_output = ida_hexrays.decompile(idaapi.get_screen_ea())
        v = ida_hexrays.get_widget_vdui(ctx.widget)
        gepetto.config.model.query_model_async(
            _("Analyze the following C function:\n{decompiler_output}"
              "\nSuggest better variable names, reply with a JSON array where keys are the original"
              " names and values are the proposed names. Do not explain anything, only print the "
              "JSON dictionary.").format(decompiler_output=str(decompiler_output)),
            functools.partial(rename_callback, address=idaapi.get_screen_ea(), view=v),
            additional_model_options={"response_format": {"type": "json_object"}})
        print(_("Request to {model} sent...").format(model=str(gepetto.config.model)))
        return 1

    def update(self, ctx):
        return idaapi.AST_ENABLE_ALWAYS

class SwapModelHandler(idaapi.action_handler_t):
    def __init__(self, new_model, plugin):
        self.new_model = new_model
        self.plugin = plugin

    def activate(self, ctx):
        try:
            gepetto.config.model = instantiate_model(self.new_model)
        except ValueError as e:
            print(_("Couldn't change model to {model}: {error}").format(model=self.new_model, error=str(e)))
            return
        gepetto.config.update_config("Gepetto", "MODEL", self.new_model)
        self.plugin.generate_model_select_menu()

    def update(self, ctx):
        return idaapi.AST_ENABLE_ALWAYS

class GenerateCCodeHandler(idaapi.action_handler_t):
    def __init__(self):
        idaapi.action_handler_t.__init__(self)

    def activate(self, ctx):
        decompiler_output = ida_hexrays.decompile(idaapi.get_screen_ea())
        v = ida_hexrays.get_widget_vdui(ctx.widget)
        if not decompiler_output:
            return 0

        gepetto.config.model.query_model_async(
            _("Please generate executable C code based on the following decompiled C code and ensure it includes all necessary header files and other information:\n{decompiler_output}").format(decompiler_output=str(decompiler_output)),
            functools.partial(self._save_c_code, view=v))
        print(_("Request to {model} sent...").format(model=str(gepetto.config.model)))
        return 1

    def _save_c_code(self, view, response):
        project_name = idaapi.get_root_filename()
        func_name = idc.get_func_name(idaapi.get_screen_ea())
        file_name = f"{project_name}_{func_name}.c"
        with open(file_name, "w", encoding="utf-8") as f:
            f.write(response)
        if view:
            view.refresh_view(False)
        print(_("{model} generated code saved to {file_name}").format(model=str(gepetto.config.model), file_name=file_name))

    def update(self, ctx):
        return idaapi.AST_ENABLE_ALWAYS

class GeneratePythonCodeHandler(idaapi.action_handler_t):
    def __init__(self):
        idaapi.action_handler_t.__init__(self)

    def activate(self, ctx):
        decompiler_output = ida_hexrays.decompile(idaapi.get_screen_ea())
        v = ida_hexrays.get_widget_vdui(ctx.widget)
        if not decompiler_output:
            return 0

        gepetto.config.model.query_model_async(
            _("Please generate equivalent Python code based on the following decompiled C code, and provide an example of the function call:\n{decompiler_output}").format(decompiler_output=str(decompiler_output)),
            functools.partial(self._save_python_code, view=v))
        print(_("Request to {model} sent...").format(model=str(gepetto.config.model)))
        return 1

    def _save_python_code(self, view, response):
        project_name = idaapi.get_root_filename()
        func_name = idc.get_func_name(idaapi.get_screen_ea())
        file_name = f"{project_name}_{func_name}.py"
        with open(file_name, "w", encoding="utf-8") as f:
            f.write(response)
        if view:
            view.refresh_view(False)
        print(_("{model} generated code saved to {file_name}").format(model=str(gepetto.config.model), file_name=file_name))

    def update(self, ctx):
        return idaapi.AST_ENABLE_ALWAYS

class RenameFunctionHandler(idaapi.action_handler_t):
    def __init__(self):
        super().__init__()

    def activate(self, ctx):
        ea = idaapi.get_screen_ea()
        cfunc = ida_hexrays.decompile(ea)
        vdui = ida_hexrays.get_widget_vdui(ctx.widget)

        if not cfunc or not vdui:
            print("Could not decompile the current function or get view.")
            return 0

        prompt = (
            "Analyze the following C function code:\n"
            f"{str(cfunc)}\n"
            "Suggest a concise new name for this function. Only reply with the new function name, prefixed with 'fn_'."
        )

        def callback(response):
            new_name = response.strip().split()[0]
            func = idaapi.get_func(ea)
            if not func:
                print("Could not find function at address.")
                return

            old_name = idc.get_func_name(func.start_ea)
            if new_name == old_name or not re.match(r'^fn_[A-Za-z_][A-Za-z0-9_]*$', new_name):
                print(f"Invalid or unchanged name suggested: {new_name}")
                return

            success = idc.set_name(func.start_ea, new_name, idc.SN_AUTO)
            if success:
                print(f"Function renamed to: {new_name}")
                if vdui:
                    vdui.refresh_view(True)
            else:
                print(f"Failed to rename function to: {new_name}")

        gepetto.config.model.query_model_async(
            prompt,
            callback,
        )

        print(_("Request to {model} sent...").format(model=str(gepetto.config.model)))
        return 1

    def update(self, ctx):
        return idaapi.AST_ENABLE_ALWAYS
        
class RenameMalwareFunctionHandler(idaapi.action_handler_t):
    def __init__(self):
        super().__init__()

    def activate(self, ctx):
        ea = idaapi.get_screen_ea()
        cfunc = ida_hexrays.decompile(ea)
        vdui = ida_hexrays.get_widget_vdui(ctx.widget)

        if not cfunc or not vdui:
            print("Could not decompile the current function or get view.")
            return 0

        prompt = (
            "Analyze the following C function code in the context of malware reverse engineering:\n"
            f"{str(cfunc)}\n"
            "Suggest a concise new name for this function. Only reply with the new function name, prefixed with 'fn_'."
        )

        def callback(response):
            new_name = response.strip().split()[0]
            func = idaapi.get_func(ea)
            if not func:
                print("Could not find function at address.")
                return

            old_name = idc.get_func_name(func.start_ea)
            if new_name == old_name or not re.match(r'^fn_[A-Za-z_][A-Za-z0-9_]*$', new_name):
                print(f"Invalid or unchanged name suggested: {new_name}")
                return

            success = idc.set_name(func.start_ea, new_name, idc.SN_AUTO)
            if success:
                print(f"Function renamed to: {new_name}")
                if vdui:
                    vdui.refresh_view(True)
            else:
                print(f"Failed to rename function to: {new_name}")

        gepetto.config.model.query_model_async(
            prompt,
            callback,
        )

        print(_("Request to {model} sent...").format(model=str(gepetto.config.model)))
        return 1

    def update(self, ctx):
        return idaapi.AST_ENABLE_ALWAYS

def malware_behavior_callback(response, address, view, start_time):
    """
    Print the explanation in IDA output window instead of adding a comment.
    """
    elapsed_time = time.time() - start_time
    print("\n===== Malicious Code Explaination =====")
    print(response.strip())
    print(f"===== End of Analysis (took {elapsed_time:.2f} seconds) =====\n")


class ExplainMalwareBehaviorHandler(idaapi.action_handler_t):
    def __init__(self):
        super().__init__()

    def activate(self, ctx):
        start_time = time.time()
        ea = idaapi.get_screen_ea()
        decompiled = ida_hexrays.decompile(ea)
        view = ida_hexrays.get_widget_vdui(ctx.widget)

        if not decompiled or not view:
            print("Unable to access function or view.")
            return 0

        prompt = _(
                "Analyze the following C function in the context of malware behavior.\n\n"
                "1. Provide a plain-text explanation in bullet or numbered points (no Markdown or code formatting).\n"
                "2. After the points, include a brief summary paragraph describing what the malicious code is doing overall.\n\n"
                "{decompiled}"
                ).format(decompiled=str(decompiled))


        gepetto.config.model.query_model_async(
            prompt,
            functools.partial(malware_behavior_callback, address=ea, view=view, start_time=start_time)
        )

        print(_("Request to {model} sent...").format(model=str(gepetto.config.model)))
        return 1

    def update(self, ctx):
        return idaapi.AST_ENABLE_ALWAYS
